#!/usr/bin/env python
# --*-- encoding: utf-8 --*--

import sqlite3
import os
import numpy as np
import json

from operator import attrgetter

#http://apprendre-python.com/page-database-data-base-donnees-query-sql-mysql-postgre-sqlite

class MeteoDataEntity():
	
	def __init__(self, station_id, date_timestamp, sea_pressure, avg_10m_windspeed, temperature, humidity, snow_height, precipitation_last_24h):
		self.station_id = station_id
		self.date_timestamp = date_timestamp
		self.sea_pressure = sea_pressure
		self.avg_10m_windspeed = avg_10m_windspeed
		self.temperature = temperature
		self.humidity = humidity
		self.snow_height = snow_height
		self.precipitation_last_24h = precipitation_last_24h
		
	def __str__(self):
		return "station_id={}, date={}, sea_p={}, wind={}, temp={}, humidity={}, snow_h={}, precip_24={}".format(self.station_id, 
																													self.date_timestamp,
																													self.sea_pressure,
																													self.avg_10m_windspeed,
																													self.temperature,
																													self.humidity,
																													self.snow_height,
																													self.precipitation_last_24h)

class DatabaseManager():

	def __init__(self, database_path):
		self.database_path = database_path
		base, filename = os.path.split(database_path)
		if not os.path.exists(base):
			os.makedirs(base)

	def _create_table_if_not_exist(self, table_name):
		try:
			#print "Creating '{}' table if necessary".format(table_name)
			conn = sqlite3.connect(self.database_path)
			cursor = conn.cursor()
			cursor.execute("CREATE TABLE {}(id INTEGER PRIMARY KEY, station_id INTEGER, timestamp INTEGER, sea_pressure INTEGER, avg_wind REAL, temperature REAL,  humidity INTEGER, snow_height REAL,  precipitation_24h REAL, CONSTRAINT station_reading UNIQUE (station_id, timestamp));".format(table_name))
			conn.close()
		except:
			#print "Table '{}' already exist".format(table_name)
			return
		#print "Table '{}' created".format(table_name)

	def insert_into_meteo_table(self, table_name, data):
		self._create_table_if_not_exist(table_name)
		print "inserting {} lines of data in {} table".format(len(data), table_name)
		try:
			conn = sqlite3.connect(self.database_path)
			cursor = conn.cursor()
			cursor.executemany("INSERT INTO {}(station_id, timestamp, sea_pressure, avg_wind, temperature,  humidity,  snow_height,  precipitation_24h) VALUES(?, ?, ?, ?, ?, ?, ?, ?)".format(table_name), data)
		except sqlite3.IntegrityError:
			print "There is something inside those data that is already in the database, REJECTING data block"
			raise sqlite3.IntegrityError()
		finally:
			conn.commit()
			conn.close()

	def insert_into_meteo_table_one_by_one(self, table_name, data):
		duplicate_counter = 0
		self._create_table_if_not_exist(table_name)
		print "inserting {} lines of data in {} table".format(len(data), table_name)
		conn = sqlite3.connect(self.database_path)
		cursor = conn.cursor()
		for element in data:
			try:
				cursor.execute("INSERT INTO {}(station_id, timestamp, sea_pressure, avg_wind, temperature,  humidity,  snow_height,  precipitation_24h) VALUES(?, ?, ?, ?, ?, ?, ?, ?)".format(table_name), element)
			except sqlite3.IntegrityError:
				#this dataline is already in the database, we are not inserting it
				duplicate_counter = duplicate_counter + 1
		print "data block inserted, {} duplicate(s) removed".format(duplicate_counter)
		conn.commit()
		conn.close()

	def select_data_from_meteo_table_between(self, table_name, station_id, oldes_ts, yougest_ts):
		"""
		get everything between [a;b] (a and b included)
		"""
		conn = sqlite3.connect(self.database_path)
		cursor = conn.cursor()
		cursor.execute("SELECT * from {} where (timestamp between {} and {}) and station_id={};".format(table_name, oldes_ts, yougest_ts, station_id))
		rows = cursor.fetchall()
		conn.close()
		
		data = []
		for line in rows:
			data.append(MeteoDataEntity(line[1], line[2], line[3], line[4], line[5], line[6], line[7], line[8])) #0 is the autogenerated id
		return data

	def get_highest_timestamp_from_meteo_data(self, table_name):
		conn = sqlite3.connect(self.database_path)
		cursor = conn.cursor()
		cursor.execute("SELECT Max(timestamp) from {}".format(table_name))
		res = int(cursor.fetchone()[0])
		conn.close()
		return res
